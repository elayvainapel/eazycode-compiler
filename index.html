<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>eazyCode Online Compiler</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1d283a 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      padding: 32px 12px;
    }

    .shell {
      width: 100%;
      max-width: 1100px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow:
        0 22px 45px rgba(15, 23, 42, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      overflow: hidden;
      backdrop-filter: blur(22px);
    }

    .header {
      padding: 14px 20px 10px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      display: flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(to right, #020617, #020617, #111827);
    }

    .traffic-dots {
      display: flex;
      gap: 6px;
      margin-right: 4px;
    }

    .traffic-dots span {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .dot-red { background: #f97373; }
    .dot-yellow { background: #facc15; }
    .dot-green { background: #22c55e; }

    .title-area {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title-main {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    .title-sub {
      font-size: 12px;
      color: #9ca3af;
    }

    .badge {
      margin-left: auto;
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      color: #c4d4ff;
      background: radial-gradient(circle at top left, #1d4ed8, #020617);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .main {
      display: grid;
      grid-template-columns: minmax(0, 1.3fr) minmax(0, 1fr);
      min-height: 420px;
    }

    .panel {
      display: flex;
      flex-direction: column;
      border-right: 1px solid rgba(31, 41, 55, 0.9);
    }
    .panel:last-child { border-right: none; }

    .panel-header {
      padding: 8px 16px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top left, #0f172a, #020617);
      display: flex;
      align-items: center;
      gap: 8px;
      color: #9ca3af;
    }

    .panel-header span.label {
      font-weight: 600;
      color: #e5e7eb;
    }

    .panel-header span.hint {
      font-size: 11px;
      margin-left: 6px;
      color: #6b7280;
    }

    .panel-header .header-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-body {
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      height: 100%;
    }

    /* Editor with line numbers */
    .editor-wrapper {
      display: flex;
      border-radius: 10px;
      overflow: hidden;
      background: #020617;
      border: 1px solid rgba(55, 65, 81, 0.98);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.8);
    }

    .line-numbers {
      width: 42px;
      flex: 0 0 42px;    /* narrow fixed gutter */
      padding: 10px 4px 10px 8px;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      text-align: right;
      color: #4b5563;
      user-select: none;
      background: #020617;
      border-right: 1px solid rgba(31, 41, 55, 0.9);
      white-space: pre;
      overflow: hidden;
    }

    textarea {
      flex: 1 1 auto;
      resize: none;
      border-radius: 0;
      background: #020617;
      border: none;
      color: #e5e7eb;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      padding: 10px 11px;
      outline: none;
      line-height: 1.45;
      tab-size: 2;
    }

    pre {
      margin: 0;
      flex: 1;
      border-radius: 10px;
      background: #020617;
      border: 1px solid rgba(55, 65, 81, 0.98);
      color: #e5e7eb;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      padding: 10px 11px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.8);
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 6px;
      gap: 8px;
    }

    .hint-ghost {
      font-size: 11px;
      color: #6b7280;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 7px 16px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, #22c55e, #4ade80);
      color: #052e16;
      box-shadow:
        0 10px 18px rgba(34, 197, 94, 0.35),
        0 0 0 1px rgba(22, 163, 74, 0.7);
    }
    button:hover {
      background: linear-gradient(135deg, #4ade80, #bbf7d0);
      transform: translateY(-0.5px);
      box-shadow:
        0 14px 24px rgba(34, 197, 94, 0.4),
        0 0 0 1px rgba(22, 163, 74, 0.9);
    }
    button:active {
      transform: translateY(1px);
      box-shadow:
        0 6px 10px rgba(34, 197, 94, 0.3),
        0 0 0 1px rgba(22, 163, 74, 0.7);
    }

    .btn-icon {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid #052e16;
      background: #bbf7d0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
    }

    .status {
      font-size: 11px;
      color: #9ca3af;
    }

    .status-dot {
      display: inline-block;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      margin-right: 5px;
      background: #6b7280;
    }
    .status.success { color: #4ade80; }
    .status.error { color: #f97373; }
    .status.success .status-dot { background: #22c55e; }
    .status.error .status-dot { background: #f97373; }

    @media (max-width: 860px) {
      .main { grid-template-columns: minmax(0, 1fr); }
      .panel { border-right: none; border-bottom: 1px solid rgba(31, 41, 55, 0.9); }
      .panel:last-child { border-bottom: none; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="header">
      <div class="traffic-dots">
        <span class="dot-red"></span>
        <span class="dot-yellow"></span>
        <span class="dot-green"></span>
      </div>
      <div class="title-area">
        <div class="title-main">eazyCode Online Compiler</div>
        <div class="title-sub">Code inside Main.main(main.execute(1)) like Java, but yours</div>
      </div>
      <div class="badge">v1.0 · slim numbers + main fixed</div>
    </div>

    <div class="main">
      <!-- Left: Editor -->
      <div class="panel">
        <div class="panel-header">
          <span class="label">Editor</span>
          <span class="hint">Class Main + main.execute(1) required</span>
          <div class="header-right">
            <button type="button" onclick="runEazyCode()">
              <span class="btn-icon">▶</span>
              Run
            </button>
          </div>
        </div>
        <div class="panel-body">
          <div class="editor-wrapper">
            <pre id="lineNumbers" class="line-numbers">1</pre>
            <textarea id="code" spellcheck="false">public class Main {
    public static void main(main.execute(1)) {
        console.print("hello world!");
    }
}</textarea>
          </div>

          <div class="controls">
            <span id="status" class="status">
              <span class="status-dot"></span>
              Ready
            </span>
            <span class="hint-ghost">Only the code inside main(main.execute(1)) is executable</span>
          </div>
        </div>
      </div>

      <!-- Right: Output -->
      <div class="panel">
        <div class="panel-header">
          <span class="label">Output</span>
          <span class="hint">Result of your eazyCode program</span>
        </div>
        <div class="panel-body">
          <pre id="output"></pre>
          <div class="controls">
            <span class="hint-ghost">console.print(...) and +.dl() appear here</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const outputEl = document.getElementById("output");
    const statusEl = document.getElementById("status");
    const editorEl = document.getElementById("code");
    const lineNumbersEl = document.getElementById("lineNumbers");

    const eazyConsole = {
      print(value = "") {
        outputEl.textContent += String(value);
        return this;
      },
      dl() {
        outputEl.textContent += "\n";
        return this;
      },
      ul() {
        outputEl.textContent += "\n";
        return this;
      }
    };

    function setStatus(text, type = "normal") {
      statusEl.textContent = "";
      const dot = document.createElement("span");
      dot.className = "status-dot";
      statusEl.className = "status";
      if (type === "success") statusEl.classList.add("success");
      if (type === "error") statusEl.classList.add("error");
      statusEl.appendChild(dot);
      statusEl.appendChild(document.createTextNode(" " + text));
    }

    function first_Int(s) {
      const m = String(s).match(/\d+/);
      return m ? parseInt(m[0], 10) : 0;
    }
    function sum_Int(s) {
      const matches = String(s).match(/\d+/g) || [];
      return matches.reduce((acc, x) => acc + parseInt(x, 10), 0);
    }
    function eachSum_Int(s) {
      const digits = String(s).match(/\d/g) || [];
      return digits.reduce((acc, d) => acc + parseInt(d, 10), 0);
    }
    function eachFirst_Int(s) {
      const m = String(s).match(/\d/);
      return m ? parseInt(m[0], 10) : 0;
    }

    // ===== Line numbers =====
    function updateLineNumbers() {
      const lines = editorEl.value.split(/\r?\n/).length;
      let out = "";
      for (let i = 1; i <= lines; i++) {
        out += i + (i < lines ? "\n" : "");
      }
      lineNumbersEl.textContent = out || "1";
    }

    editorEl.addEventListener("input", updateLineNumbers);
    editorEl.addEventListener("scroll", () => {
      lineNumbersEl.scrollTop = editorEl.scrollTop;
    });
    updateLineNumbers();

    // ===== Extract main body + region =====
    function extractMainRegion(source) {
      const sig = "public static void main(main.execute(1))";
      const sigIndex = source.indexOf(sig);
      if (sigIndex === -1) {
        throw new Error("main.execute(1) method not found");
      }
      const braceStart = source.indexOf("{", sigIndex);
      if (braceStart === -1) {
        throw new Error("Opening { for main.execute(1) not found");
      }
      let depth = 1;
      const n = source.length;
      const bodyStart = braceStart + 1;
      for (let i = braceStart + 1; i < n; i++) {
        const ch = source[i];
        if (ch === "{") depth++;
        else if (ch === "}") {
          depth--;
          if (depth === 0) {
            const bodyEnd = i;
            return {
              body: source.slice(bodyStart, bodyEnd),
              bodyStart,
              bodyEnd
            };
          }
        }
      }
      throw new Error("Could not find matching } for main.execute(1)");
    }

    // ===== No executable code outside main (console.print/for/while/if) =====
    function validateOutsideMain(source, mainStart, mainEnd) {
      const errors = [];
      const patterns = [
        {
          re: /console\.print\s*\(/g,
          msg: "console.print is only allowed inside main(main.execute(1))"
        },
        {
          re: /\bfor\s*\(/g,
          msg: "for-loops are only allowed inside main(main.execute(1))"
        },
        {
          re: /\bwhile\s*\(/g,
          msg: "while-loops are only allowed inside main(main.execute(1))"
        },
        {
          re: /\bif\s*\(/g,
          msg: "if-statements are only allowed inside main(main.execute(1))"
        }
      ];

      function indexToLine(idx) {
        return source.slice(0, idx).split(/\r?\n/).length;
      }

      for (const { re, msg } of patterns) {
        re.lastIndex = 0;
        let m;
        while ((m = re.exec(source)) !== null) {
          const idx = m.index;
          if (idx < mainStart || idx >= mainEnd) {
            const line = indexToLine(idx);
            errors.push(`Line ${line}: ${msg}`);
          }
        }
      }
      return errors;
    }

    // ===== Global syntax validation outside main =====
    function validateGlobalSyntax(source, mainStart, mainEnd) {
      const lines = source.split(/\r?\n/);
      const errors = [];
      let offset = 0;

      for (let i = 0; i < lines.length; i++) {
        const lineText = lines[i];
        const lineNo = i + 1;
        const trimmed = lineText.trim();
        const lineStart = offset;
        const lineEnd = offset + lineText.length;
        offset = lineEnd + 1;

        if (trimmed === "") continue;

        // Any line that contains "main.execute(1)" is always allowed
        if (lineText.includes("main.execute(1)")) {
          continue;
        }

        // Lines inside main body are handled by compileEazy – skip them
        const intersectsMain = !(lineEnd <= mainStart || lineStart >= mainEnd);
        if (intersectsMain) continue;

        // Comments
        if (trimmed.startsWith("//")) continue;

        // Single braces
        if (trimmed === "{" || trimmed === "}") continue;

        // Class declarations
        if (/^(public\s+)?class\s+[A-Za-z_]\w*\s*\{?\s*$/.test(trimmed)) {
          continue;
        }

        // Other method headers outside main
        if (/^(public\s+)?(static\s+)?(int|String|var|void)\s+[A-Za-z_]\w*\s*\([^)]*\)\s*\{?\s*$/.test(trimmed)) {
          continue;
        }

        const isControl =
          trimmed.startsWith("for ") ||
          trimmed.startsWith("if ") ||
          trimmed.startsWith("else if ") ||
          trimmed.startsWith("else ") ||
          trimmed.startsWith("while ");

        const needsSemicolon = !isControl;

        if (needsSemicolon && !lineText.includes(";")) {
          errors.push(`Line ${lineNo}: Missing ';' at end of line`);
          continue;
        }

        // Recognised declarations
        if (/^(int|String|var|static\s+int|static\s+String|static\s+var)\s+([A-Za-z_]\w*)\s*=\s*.+;?$/.test(trimmed)) {
          continue;
        }

        // Recognised console.print(...)
        if (/^console\.print\((.*)\)\s*\+\s*\.dl\(\)\s*;?$/.test(trimmed)) {
          continue;
        }
        if (/^console\.print\((.*)\)\s*;?$/.test(trimmed)) {
          continue;
        }

        // for (int i:range++(1,5)){
        if (/^for\s*\(\s*int\s+([A-Za-z_]\w*)\s*:\s*range\+\+\(\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\{?/.test(trimmed)) {
          continue;
        }

        // if/else/while outside main – structure allowed
        if (isControl) {
          continue;
        }

        errors.push(`Line ${lineNo}: Cannot compile statement outside main: ${trimmed}`);
      }

      return errors;
    }

    function translateExpression(expr) {
      let e = expr.trim();
      e = e.replace(/first\.Int/g, "first_Int");
      e = e.replace(/sum\.Int/g, "sum_Int");
      e = e.replace(/eachSum\.Int/g, "eachSum_Int");
      e = e.replace(/eachFirst\.Int/g, "eachFirst_Int");
      return e;
    }

    // ===== Compile main body to JS (strict ; inside main) =====
    function compileEazy(code, baseLine) {
      const lines = code.split(/\r?\n/);
      const out = [];
      const errors = [];

      function addError(msg) {
        errors.push(msg);
      }

      function processStatement(rawSegment, lineNo) {
        const line = rawSegment;
        const trimmed = line.trim();

        if (trimmed === "") return;

        if (trimmed === "{" || trimmed === "}") {
          out.push(trimmed);
          return;
        }

        if (trimmed.startsWith("//")) {
          out.push("//" + trimmed.slice(2));
          return;
        }

        // console.print(...)+.dl();
        let m = trimmed.match(/^console\.print\((.*)\)\s*\+\s*\.dl\(\)\s*;?$/);
        if (m) {
          const inner = m[1].trim();
          if (inner) {
            const jsExpr = translateExpression(inner);
            out.push(`eazyConsole.print(${jsExpr});`);
          } else {
            out.push(`eazyConsole.print("");`);
          }
          out.push(`eazyConsole.dl();`);
          return;
        }

        // console.print(...);
        m = trimmed.match(/^console\.print\((.*)\)\s*;?$/);
        if (m) {
          const inner = m[1].trim();
          if (inner) {
            const jsExpr = translateExpression(inner);
            out.push(`eazyConsole.print(${jsExpr});`);
          } else {
            out.push(`eazyConsole.print("");`);
          }
          return;
        }

        // declarations
        m = trimmed.match(/^(int|String|var|static\s+int|static\s+String|static\s+var)\s+([A-Za-z_]\w*)\s*=\s*(.+);?$/);
        if (m) {
          const name = m[2];
          const expr = translateExpression(m[3]);
          out.push(`let ${name} = ${expr};`);
          return;
        }

        // for (int i:range++(1,5)){
        m = trimmed.match(
          /^for\s*\(\s*int\s+([A-Za-z_]\w*)\s*:\s*range\+\+\(\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\{?$/
        );
        if (m) {
          const varName = m[1];
          const start = translateExpression(m[2]);
          const end = translateExpression(m[3]);
          out.push(
            `for (let ${varName} = ${start}; ${varName} <= ${end}; ${varName}++) {`
          );
          return;
        }

        // if / else if / while
        if (
          trimmed.startsWith("if ") ||
          trimmed.startsWith("else if ") ||
          trimmed.startsWith("while ")
        ) {
          let lineCopy = line;
          const idxOpen = lineCopy.indexOf("(");
          const idxClose = lineCopy.lastIndexOf(")");
          if (idxOpen !== -1 && idxClose !== -1 && idxClose > idxOpen) {
            const before = lineCopy.slice(0, idxOpen + 1);
            const expr = lineCopy.slice(idxOpen + 1, idxClose);
            const after = lineCopy.slice(idxClose);
            lineCopy = before + translateExpression(expr) + after;
          }
          out.push(lineCopy);
          return;
        }

        // assignment
        m = trimmed.match(/^([A-Za-z_]\w*)\s*=\s*(.+);?$/);
        if (m && !trimmed.startsWith("for ")) {
          const name = m[1];
          const expr = translateExpression(m[2]);
          out.push(`${name} = ${expr};`);
          return;
        }

        addError(`Line ${lineNo}: Cannot compile statement: ${trimmed}`);
      }

      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const physicalLineNo = baseLine + i;
        const trimmed = raw.trim();

        if (trimmed === "") {
          out.push("");
          continue;
        }

        const isCommentLine = trimmed.startsWith("//");
        const isBraceOnly = trimmed === "{" || trimmed === "}";
        const isControl =
          trimmed.startsWith("for ") ||
          trimmed.startsWith("if ") ||
          trimmed.startsWith("else if ") ||
          trimmed.startsWith("else ") ||
          trimmed.startsWith("while ");

        const needsSemicolon = !isCommentLine && !isBraceOnly && !isControl;

        if (needsSemicolon && !raw.includes(";")) {
          addError(`Line ${physicalLineNo}: Missing ';' at end of line`);
          continue;
        }

        if (!raw.includes(";")) {
          processStatement(raw, physicalLineNo);
          continue;
        }

        let remaining = raw;
        while (true) {
          const idx = remaining.indexOf(";");
          if (idx === -1) break;
          const segment = remaining.slice(0, idx + 1);
          processStatement(segment, physicalLineNo);
          remaining = remaining.slice(idx + 1);
        }

        const leftover = remaining;
        const leftoverTrimmed = leftover.trim();
        if (leftoverTrimmed.length === 0) {
          continue;
        }

        if (leftoverTrimmed.startsWith("//")) {
          processStatement(leftover, physicalLineNo);
        } else if (!needsSemicolon) {
          processStatement(leftover, physicalLineNo);
        } else {
          addError(
            `Line ${physicalLineNo}: Missing ';' before "${leftoverTrimmed}"`
          );
        }
      }

      return { js: out.join("\n"), errors };
    }

    // ===== Run pipeline =====
    function runEazyCode() {
      const fullSource = editorEl.value;
      outputEl.textContent = "";
      setStatus("Extracting main...", "normal");

      const allErrors = [];
      let region = null;

      try {
        region = extractMainRegion(fullSource);
      } catch (err) {
        allErrors.push(err.message);
      }

      if (!region) {
        const syntaxErrors = validateGlobalSyntax(
          fullSource,
          fullSource.length + 1,
          fullSource.length + 1
        );
        allErrors.push(...syntaxErrors);
        allErrors.forEach(msg => {
          outputEl.textContent += "[Error] " + msg + "\n";
        });
        setStatus("Error", "error");
        return;
      }

      const outsideErrors = validateOutsideMain(
        fullSource,
        region.bodyStart,
        region.bodyEnd
      );
      allErrors.push(...outsideErrors);

      const syntaxErrors = validateGlobalSyntax(
        fullSource,
        region.bodyStart,
        region.bodyEnd
      );
      allErrors.push(...syntaxErrors);

      const prefix = fullSource.slice(0, region.bodyStart);
      const baseLine = prefix.split(/\r?\n/).length;

      setStatus("Compiling...", "normal");
      const compileResult = compileEazy(region.body, baseLine);
      allErrors.push(...compileResult.errors);

      if (allErrors.length > 0) {
        allErrors.forEach(msg => {
          outputEl.textContent += "[Error] " + msg + "\n";
        });
        setStatus(
          `Found ${allErrors.length} error${allErrors.length > 1 ? "s" : ""}`,
          "error"
        );
        return;
      }

      setStatus("Running...", "normal");
      try {
        eval(compileResult.js);
        setStatus("Done", "success");
      } catch (err) {
        outputEl.textContent += "[Runtime Error] " + err.message + "\n";
        setStatus("Error", "error");
      }
    }

    // ===== Editor shortcuts (pairs, tab, backspace, smart { } on Enter) =====
    function insertPair(el, openChar, closeChar, event) {
      event.preventDefault();
      const start = el.selectionStart;
      const end = el.selectionEnd;
      const value = el.value;
      const selected = value.slice(start, end);
      const before = value.slice(0, start);
      const after = value.slice(end);

      if (selected.length > 0) {
        el.value = before + openChar + selected + closeChar + after;
        el.selectionStart = start + 1;
        el.selectionEnd = start + 1 + selected.length;
      } else {
        el.value = before + openChar + closeChar + after;
        el.selectionStart = el.selectionEnd = start + 1;
      }
      updateLineNumbers();
    }

    function insertText(el, text, event) {
      if (event) event.preventDefault();
      const start = el.selectionStart;
      const end = el.selectionEnd;
      const value = el.value;
      const before = value.slice(0, start);
      const after = value.slice(end);
      el.value = before + text + after;
      el.selectionStart = el.selectionEnd = start + text.length;
      updateLineNumbers();
    }

    editorEl.addEventListener("keydown", function (e) {
      // auto-pairs
      if (e.key === "(") {
        insertPair(editorEl, "(", ")", e);
        return;
      }
      if (e.key === "[") {
        insertPair(editorEl, "[", "]", e);
        return;
      }
      if (e.key === '"') {
        insertPair(editorEl, '"', '"', e);
        return;
      }

      // smart Backspace
      if (e.key === "Backspace") {
        const el = editorEl;
        const pos = el.selectionStart;
        const value = el.value;

        if (pos > 0 && el.selectionStart === el.selectionEnd) {
          const before = value[pos - 1];
          const after = value[pos];
          const pairs = { "(": ")", "[": "]", '"': '"' };
          if (pairs[before] && pairs[before] === after) {
            e.preventDefault();
            el.value = value.slice(0, pos - 1) + value.slice(pos + 1);
            el.selectionStart = el.selectionEnd = pos - 1;
            updateLineNumbers();
            return;
          }
        }

        // delete 4-space tab at once
        if (el.selectionStart === el.selectionEnd && pos >= 4) {
          const chunk = value.slice(pos - 4, pos);
          if (chunk === "    ") {
            e.preventDefault();
            el.value = value.slice(0, pos - 4) + value.slice(pos);
            el.selectionStart = el.selectionEnd = pos - 4;
            updateLineNumbers();
            return;
          }
        }
      }

      // Tab → 4 spaces
      if (e.key === "Tab") {
        insertText(editorEl, "    ", e);
        return;
      }

      // Enter: smart indent + local { } pairing
      if (e.key === "Enter") {
        const el = editorEl;
        const start = el.selectionStart;
        const value = el.value;
        const before = value.slice(0, start);
        const after = value.slice(start);
        const lastNewline = before.lastIndexOf("\n");
        const lineStart = lastNewline === -1 ? 0 : lastNewline + 1;
        const currentLine = before.slice(lineStart);
        const indentMatch = currentLine.match(/^[\t ]*/);
        const currentIndent = indentMatch ? indentMatch[0] : "";
        const trimmedLine = currentLine.trimEnd();
        const indentUnit = "    ";

        if (trimmedLine.endsWith("{")) {
          e.preventDefault();
          const afterTrim = after.replace(/^[ \t]*/, "");
          if (afterTrim.startsWith("}")) {
            // { already has immediate } → just indent between
            const newText =
              before + "\n" + currentIndent + indentUnit + after;
            el.value = newText;
            const cursorPos =
              before.length + 1 + currentIndent.length + indentUnit.length;
            el.selectionStart = el.selectionEnd = cursorPos;
          } else {
            // create a new block with closing }
            const newText =
              before +
              "\n" +
              currentIndent +
              indentUnit +
              "\n" +
              currentIndent +
              "}" +
              after;
            el.value = newText;
            const cursorPos =
              before.length + 1 + currentIndent.length + indentUnit.length;
            el.selectionStart = el.selectionEnd = cursorPos;
          }
        } else {
          e.preventDefault();
          const newText = before + "\n" + currentIndent + after;
          el.value = newText;
          const cursorPos = before.length + 1 + currentIndent.length;
          el.selectionStart = el.selectionEnd = cursorPos;
        }
        updateLineNumbers();
      }
    });
  </script>
</body>
</html>
